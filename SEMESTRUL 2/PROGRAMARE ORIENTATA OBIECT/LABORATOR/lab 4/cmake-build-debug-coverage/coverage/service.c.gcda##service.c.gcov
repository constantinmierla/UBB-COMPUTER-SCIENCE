        -:    0:Source:D:/FMI UBB CLUJ 2023-2026/UBB-COMPUTER-SCIENCE/SEMESTRUL 2/PROGRAMARE ORIENTATA OBIECT/LABORATOR/lab 4/Service/service.c
        -:    0:Graph:D:\FMI UBB CLUJ 2023-2026\UBB-COMPUTER-SCIENCE\SEMESTRUL 2\PROGRAMARE ORIENTATA OBIECT\LABORATOR\lab 4\cmake-build-debug-coverage\CMakeFiles\Lab2.dir\Service\service.c.gcno
        -:    0:Data:D:\FMI UBB CLUJ 2023-2026\UBB-COMPUTER-SCIENCE\SEMESTRUL 2\PROGRAMARE ORIENTATA OBIECT\LABORATOR\lab 4\cmake-build-debug-coverage\CMakeFiles\Lab2.dir\Service\service.c.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <string.h>
        -:    3:#include "./service.h"
        -:    4:
function compareProducts called 3 returned 100% blocks executed 100%
        3:    5:int compareProducts(Product productA, Product productB) {
        -:    6:    // Compare by price
        3:    7:    if (productA.price != productB.price) {
        3:    7-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:    8:        return productA.price - productB.price;
        1:    8-block  0
        -:    9:    }
        -:   10:
        -:   11:    // If prices are equal, compare by quantity
        2:   12:    return productA.quantity - productB.quantity;
        2:   12-block  0
        -:   13:}
        -:   14:
        -:   15:
function setUp called 8 returned 100% blocks executed 100%
        8:   16:void setUp(Service *service) {
        8:   17:    service->id = 0;
        8:   18:}
        -:   19:
function getAllService called 5 returned 100% blocks executed 100%
        5:   20:Product* getAllService(Service *service) {
        5:   21:    return getAll(service->repository);
        5:   21-block  0
call    0 returned 5
        -:   22:}
        -:   23:
function addProduct called 109 returned 100% blocks executed 100%
      109:   24:int addProduct(Service *service, Product product) {
      109:   25:    product.id = service->id;
      109:   26:    if (validateProduct(product) == 1) {
      109:   26-block  0
call    0 returned 109
branch  1 taken 18 (fallthrough)
branch  2 taken 91
       18:   27:        add(service->repository, product);
       18:   27-block  0
call    0 returned 18
       18:   28:        service->id++;
       18:   29:        return 0;
        -:   30:    } else {
       91:   31:        return -1;
       91:   31-block  0
        -:   32:    }
        -:   33:}
        -:   34:
function updatePriceForProduct called 3 returned 100% blocks executed 100%
        3:   35:int updatePriceForProduct(Service *service, int id, int price) {
        3:   36:    updatePrice(service->repository, id, price);
        3:   36-block  0
call    0 returned 3
        3:   37:    return 0;
        -:   38:}
        -:   39:
function updateQuantityForProduct called 2 returned 100% blocks executed 100%
        2:   40:int updateQuantityForProduct(Service *service, int id, int quantity) {
        2:   41:    updateQuantity(service->repository, id, quantity);
        2:   41-block  0
call    0 returned 2
        2:   42:    return 0;
        -:   43:}
        -:   44:
function deleteProduct called 1 returned 100% blocks executed 100%
        1:   45:int deleteProduct(Service *service, int id) {
        1:   46:    delete(service->repository, id);
        1:   46-block  0
call    0 returned 1
        1:   47:    return 0;
        -:   48:}
        -:   49:
function getProduct called 3 returned 100% blocks executed 100%
        3:   50:Product getProduct(Service service, int id) {
        3:   51:    Product a = find(*service.repository, id);
        3:   51-block  0
call    0 returned 3
        3:   52:    return a;
        -:   53:}
        -:   54:
function customSortProducts called 1 returned 100% blocks executed 92%
        1:   55:void customSortProducts(Product* products, int size, int (*compare)(Product productA, Product productB), int reverse) {
        3:   56:    for (int i = 0; i < size - 1; ++i) {
        1:   56-block  0
        2:   56-block  1
        3:   56-block  2
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        5:   57:        for (int j = 0; j < size - i - 1; ++j) {
        2:   57-block  0
        3:   57-block  1
        5:   57-block  2
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3:   58:            int comparisonResult = compare(products[j], products[j + 1]);
        3:   58-block  0
call    0 returned 3
       3*:   59:            if ((reverse == 1 && comparisonResult > 0) || (reverse == 2 && comparisonResult < 0)) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:   59-block  0
branch  2 taken 2 (fallthrough)
branch  3 taken 1
        2:   59-block  1
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    %%%%%:   59-block  2
branch  6 never executed (fallthrough)
branch  7 never executed
        -:   60:                // Swap products
        1:   61:                Product temp = products[j];
        1:   62:                products[j] = products[j + 1];
        1:   63:                products[j + 1] = temp;
        1:   63-block  0
        -:   64:            }
        -:   65:        }
        -:   66:    }
        1:   67:}
        -:   68:
function sortProducts called 1 returned 100% blocks executed 100%
        1:   69:Product *sortProducts(Service service, int reverse) {
        1:   70:    Product* products = getAllService(&service);
        1:   70-block  0
call    0 returned 1
        1:   71:    int size = service.repository->count;
        -:   72:    // Allocate memory for the copy of sorted products
        1:   73:    Product *sortedProducts = malloc(size * sizeof(Product));
        -:   74:    // Copy the pointers from the original array to the copy
        1:   75:    memcpy(sortedProducts, products, size * sizeof(Product));
        -:   76:
        -:   77:    // Sort the copied array
        1:   78:    customSortProducts(sortedProducts, size, compareProducts, reverse);
call    0 returned 1
        -:   79:
        1:   80:    return sortedProducts;
        -:   81:}
        -:   82:
function filterProducts called 3 returned 100% blocks executed 100%
        3:   83:Product* filterProducts(Service service, const char* criteria, int value, int* filteredSize, char* producer) {
        -:   84:    // Allocate memory for the filtered products
        3:   85:    Product* products = getAllService(&service);
        3:   85-block  0
call    0 returned 3
        3:   86:    int size = service.repository->count;
        3:   87:    Product* filteredProducts = malloc(size * sizeof(Product));
        -:   88:
        3:   89:    *filteredSize = 0;
        -:   90:
       12:   91:    for (int i = 0; i < size; ++i) {
        9:   91-block  0
       12:   91-block  1
branch  0 taken 9
branch  1 taken 3 (fallthrough)
        9:   92:        if (strcmp(criteria, "price") == 0 && products[i].price == value) {
        9:   92-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:   92-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 2
        1:   93:            filteredProducts[(*filteredSize)++] = products[i];
        1:   93-block  0
        8:   94:        } else if (strcmp(criteria, "quantity") == 0 && products[i].quantity == value) {
        8:   94-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 5
        3:   94-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 2
        1:   95:            filteredProducts[(*filteredSize)++] = products[i];
        1:   95-block  0
        7:   96:        } else if (strcmp(criteria, "producer") == 0 && strcmp(products[i].producer, producer) == 0) {
        7:   96-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        3:   96-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 2
        1:   97:            filteredProducts[(*filteredSize)++] = products[i];
        1:   97-block  0
        -:   98:        }
        -:   99:    }
        -:  100:
        3:  101:    filteredProducts = realloc(filteredProducts, (*filteredSize) * sizeof(Product));
        -:  102:
        3:  103:    return filteredProducts;
        3:  103-block  0
        -:  104:}
