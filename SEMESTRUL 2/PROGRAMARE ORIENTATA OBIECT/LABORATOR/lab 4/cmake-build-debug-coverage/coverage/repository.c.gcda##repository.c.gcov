        -:    0:Source:D:/FMI UBB CLUJ 2023-2026/UBB-COMPUTER-SCIENCE/SEMESTRUL 2/PROGRAMARE ORIENTATA OBIECT/LABORATOR/lab 4/Repository/repository.c
        -:    0:Graph:D:\FMI UBB CLUJ 2023-2026\UBB-COMPUTER-SCIENCE\SEMESTRUL 2\PROGRAMARE ORIENTATA OBIECT\LABORATOR\lab 4\cmake-build-debug-coverage\CMakeFiles\Lab2.dir\Repository\repository.c.gcno
        -:    0:Data:D:\FMI UBB CLUJ 2023-2026\UBB-COMPUTER-SCIENCE\SEMESTRUL 2\PROGRAMARE ORIENTATA OBIECT\LABORATOR\lab 4\cmake-build-debug-coverage\CMakeFiles\Lab2.dir\Repository\repository.c.gcda
        -:    0:Runs:1
        -:    1:#include "./repository.h"
        -:    2:#include <stdlib.h>
        -:    3:
        -:    4:
function getAll called 6 returned 100% blocks executed 100%
        6:    5:Product* getAll(Repository *repo) {
        6:    6:    return repo->products;
        6:    6-block  0
        -:    7:}
        -:    8:
function initRepository called 14 returned 100% blocks executed 100%
       14:    9:void initRepository(Repository *repo, int size) {
       14:   10:    repo->count = 0;
       14:   11:    repo->products = malloc(size * sizeof(Product));
        -:   12:
      246:   13:    for (int i = 0; i < size; i++) {
       14:   13-block  0
      246:   13-block  1
branch  0 taken 232
branch  1 taken 14 (fallthrough)
      232:   14:        repo->products[i].id = -1;
      232:   14-block  0
        -:   15:    }
       14:   16:}
        -:   17:
function add called 26 returned 100% blocks executed 100%
       26:   18:void add(Repository *repo, Product product){
       26:   19:    if (repo->products[product.id].id == product.id && repo->products[product.id].quantity != 0 && repo->products[product.id].price != 0) {
       26:   19-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 25
        1:   19-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:   19-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:   20:        repo->products[product.id].quantity++;
        1:   20-block  0
        -:   21:    } else {
       25:   22:        repo->products[product.id] = product;
       25:   23:        repo->count++;
       25:   23-block  0
        -:   24:    }
       26:   25:}
        -:   26:
function find called 8 returned 100% blocks executed 100%
        8:   27:Product find(Repository repo, int id) {
        8:   28:    if (repo.products[id].id != -1 && id < repo.count) {
        8:   28-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:   28-block  1
branch  2 taken 6 (fallthrough)
branch  3 taken 2
        6:   29:        return repo.products[id];
        6:   29-block  0
        -:   30:    } else {
        -:   31:        Product a;
        2:   32:        a.id = -2;
        2:   33:        return a;
        2:   33-block  0
        -:   34:    }
        -:   35:}
        -:   36:
function updatePrice called 4 returned 100% blocks executed 100%
        4:   37:void updatePrice(Repository *repo, int id, int price) {
        4:   38:    if (repo->products[id].id == id){
        4:   38-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:   39:        repo->products[id].price = price;
        4:   39-block  0
        -:   40:    }
        4:   41:}
        -:   42:
function updateQuantity called 3 returned 100% blocks executed 100%
        3:   43:void updateQuantity(Repository *repo, int id, int quantity) {
        3:   44:    if (repo->products[id].id == id) {
        3:   44-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:   45:        repo->products[id].quantity = quantity;
        3:   45-block  0
        -:   46:    }
        3:   47:}
        -:   48:
        -:   49:
function delete called 3 returned 100% blocks executed 100%
        3:   50:int delete(Repository *repository, int id) {
        3:   51:    int found = -1;
        4:   52:    for (int i = 0; i < repository->count; i++) {
        3:   52-block  0
        1:   52-block  1
        4:   52-block  2
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        3:   53:        if (repository->products[i].id == id) {
        3:   53-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:   54:            // Shift remaining elements to the left to remove the product
        3:   55:            for (int j = i; j < repository->count - 1; j++) {
        2:   55-block  0
        3:   55-block  1
branch  0 taken 1
branch  1 taken 2 (fallthrough)
        1:   56:                repository->products[j] = repository->products[j + 1];
        1:   56-block  0
        -:   57:            }
        2:   58:            found = 1;
        2:   59:            repository->count--;
        2:   60:            break;
        2:   60-block  0
        -:   61:        }
        -:   62:    }
        3:   63:    return found;
        3:   63-block  0
        -:   64:}
